#+TITLE: NoLisp3
#+AUTHOR: Nolan Eakins <sneakin@semanticgap.com>

A proof of concept Lisp compiler that transforms to continuation passing style and then
into a Forth dialect.

More a proof of concept than useful.

* Dependencies

  * A Common Lisp: tested with SBCL and ECL
  * ASDF

* Installation

** Development

Configure ASDF's source registry so it can find ~nolisp.asd~:

#+BEGIN_SRC shell
  export NOLISP=$(pwd)
  mkdir -p ~/.config/common-lisp/source-registry.conf.d
  echo "(:directory (:home \"$NOLISP\"))" > ~/.config/common-lisp/source-registry.conf.d/nolisp.conf
#+END_SRC

Or by adding the NoLisp directory to ~asdf:*centrol-registry*~ such as the
following for the current directory:

#+BEGIN_SRC lisp
  (push *default-pathname-defaults* asdf:*central-registry*)
#+END_SRC

** Building CLI Frontend

A command line executable can be built using ECL or SBCL. To do so run
either of the following depending on your Lisp:

ECL:

#+BEGIN_SRC shell
./src/nolisp/cli/ecl/build.lisp
#+END_SRC

SBCL:

#+BEGIN_SRC shell
./src/nolisp/cli/sbcl/build.lisp
#+END_SRC

There's a ~main.lisp~ that can be executed directly without building a
binary.


* Usage

** Loading

#+BEGIN_SRC lisp
  (require :asdf)
  ;; possibly update asdf:*central-registry*
  (require :nolisp)
#+END_SRC

** API

The primary interface is through the ~compile-to-forth~ function:

#+BEGIN_SRC lisp
(nolisp:compile-to-forth '(defun sq (x) (* x x)))
#+END_SRC

The first argument is the form to be compiled. A second argument is accepted
to specify what stage to stop at. See the ~nolisp:*stages*~ alist for
possible values:

#+BEGIN_SRC lisp
(nolisp:compile-to-forth '(defun sq (x) (* x x)) 'cps-transform)
#+END_SRC

** Tests

*** From Lisp

#+BEGIN_SRC lisp
  (load "tests/run.lisp")
  (run-tests)
#+END_SRC

*** From Unix shell

Using SBCL:

#+BEGIN_SRC shell
  sbcl --script ./tests/run-sbcl.lisp
#+END_SRC

Using ECL:

#+BEGIN_SRC shell
  ecl --shell ./tests/run-ecl.lisp
#+END_SRC
