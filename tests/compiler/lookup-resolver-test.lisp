(defun test-lookup-walker ()
  (assert-matches '((x x)
                    ((defun f (x y)
                      (* y y (λ (r0) (* x r0 RETURN))))
                     (defun f (x y)
                      (* (argn 1) (argn 1)
                         (λ (:R) (* (lookup 1 0) (argn 0) RETURN))))
                     "lambda forms add a frame")
                    ((lambda (x y) (f x y RETURN) RETURN)
		     (lambda (?cc x y) (f (argn 1) (argn 2) RETURN) RETURN)
                     "adds a closing frame pointer")
		    (((lambda (x) (who x RETURN) (λ (R) (R 3 4 5)) RETURN))
		     ((lambda (?cc x) (who (argn 1) RETURN) (λ (R) ((argn 0) 3 4 5)) RETURN))
		     "lambda in first position")
		    ((defun f (x) (lambda (y) (+ x y RETURN) RETURN))
		     (defun f (x) (lambda (?cc y) (+ (closure-lookup 0 0 0 0) (argn 1) RETURN) RETURN))
		     "lambda with closure lookup")
		    ((defun f (x) (lambda (n) (* x n (λ (r0) (+ x r0 (λ (r1) (* x n r1 RETURN))))) RETURN))
		     (defun f (x) (lambda (?cc n)
				    (* (closure-lookup 0 0 0 0)
				       (argn 1)
				       (λ (?r0)
					  (+ (closure-lookup 0 1 0 0) (argn 0)
					     (λ (?r1) (* (closure-lookup 0 2 0 0) (lookup 2 1) (argn 0) RETURN)))))
				    RETURN))
		     "defun w/ lambda w/ nested lookup")
		    ((LAMBDA (X) (LAMBDA (Y) (LAMBDA (Z) (* X Y Z RETURN) RETURN) RETURN) RETURN)
		     (LAMBDA (?CC0 X)
		       (LAMBDA (?CC1 Y)
			 (LAMBDA (?CC2 Z) (* (CLOSURE-LOOKUP 1 0 0 1)
					     (CLOSURE-LOOKUP 0 0 0 1)
					     (ARGN 1)
					     RETURN)
			   RETURN)
			 RETURN)
		       RETURN)
		     "deeply nested closed lookups")
		    ((LAMBDA (X)
		       (LAMBDA (Y)
			 (LAMBDA (Z) (* X Y Z RETURN) (λ (R1) (+ x y z R1 RETURN)))
			 (λ (R2) (+ x y z R2 RETURN)))
		       (λ (R3) (+ x y z R3 RETURN)))
		     (LAMBDA (?CC0 X)
		       (LAMBDA (?CC1 Y)
			 (LAMBDA (?CC2 Z)
			   (* (closure-lookup 1 0 0 1)
			      (closure-lookup 0 0 0 1)
			      (argn 1)
			      RETURN)
			   (λ (R1) (+ (closure-lookup 0 1 0 1)
				      (lookup 1 1) z (argn 0)
				      RETURN)))
			 (λ (R2) (+ (lookup 1 1) y z (argn 0) RETURN)))
		       (λ (R3) (+ x y z (argn 0) RETURN)))
		     "deeply nested lookup")
                    ((if x (return a) (return b))
                     (if x (return a) (return b))
                     "unknown symbols pass through")
                    ((λ (x y) (a x (λ (R0) (b x (λ (R1) (* y R0 R1))))))
                     (λ (x y) (a (argn 0)
                                 (λ (R0) (b (lookup 1 0)
                                            (λ (R1) (* (lookup 2 1)
                                                       (lookup 1 0)
                                                       (argn 0)))))))
                     "nested lambdas as arguments add a frame")
                    ((λ (x) (/ x y
                               (λ (R0)
                                  (to-int R0 (λ (R1)
                                                (if R1
                                                    (return x)
                                                    (return y)))))))
                     (λ (x) (/ (argn 0) y
                               (λ (:R0)
                                  (to-int (argn 0)
                                          (λ (:R1)
                                             (if (argn 0)
                                                 (return (lookup 2 0))
                                                 (return y)))))))
                     "nested lambda forms increase lookup depth")
		    ((DEFUN F (A)
		       (LAMBDA (R)
			       (+ 2 A R RETURN)
			       (Λ (CC) (> A 0 (Λ (TEST) (IF TEST (CC A) (- A CC)))))))
		     (DEFUN F (A)
		       (LAMBDA (?CC R)
			       (+ 2 (closure-lookup 0 0 0 0) (argn 1) RETURN)
			       (Λ (CC) (> (lookup 1 0) 0
					  (Λ (TEST) (IF (argn 0)
							((lookup 1 0) (lookup 2 0))
							(- (lookup 2 0) (lookup 1 0))))))))
		     "lookups for function args inside an IF lambda"))
                  :fn #'nolisp:lookup-resolver))
