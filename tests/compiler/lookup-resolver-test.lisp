(defun test-lookup-walker ()
  (assert-matches '((x x)
                    ((defun f (x y)
                      (* y y (λ (r0) (* x r0 RETURN))))
                     (defun f (x y)
                      (* (argn 1) (argn 1)
                         (λ (:R) (* (lookup 1 0) (argn 0) RETURN))))
                     "lambda forms add a frame")
                    ((lambda (x y) (f x y RETURN) RETURN)
		     (lambda (?cc x y) (f (argn 1) (argn 2) RETURN) RETURN)
                     "adds a closing frame pointer")
		    (((lambda (x) (who x RETURN) (λ (R) (R 3 4 5)) RETURN))
		     ((lambda (?cc x) (who (argn 1) RETURN) (λ (R) ((argn 0) 3 4 5)) RETURN))
		     "lambda in first position")
		    ((defun f (x) (lambda (y) (+ x y RETURN) RETURN))
		     (defun f (x) (lambda (?cc y) (+ (closure-lookup 0 0) (argn 1) RETURN) RETURN))
		     "lambda with closure lookup")
                    ((if x (return a) (return b))
                     (if x (return a) (return b))
                     "unknown symbols pass through")
                    ((λ (x y) (a x (λ (R0) (b x (λ (R1) (* y R0 R1))))))
                     (λ (x y) (a (argn 0)
                                 (λ (R0) (b (lookup 1 0)
                                            (λ (R1) (* (lookup 2 1)
                                                       (lookup 1 0)
                                                       (argn 0)))))))
                     "nested lambdas as arguments add a frame")
                    ((λ (x) (/ x y
                               (λ (R0)
                                  (to-int R0 (λ (R1)
                                                (if R1
                                                    (return x)
                                                    (return y)))))))
                     (λ (x) (/ (argn 0) y
                               (λ (:R0)
                                  (to-int (argn 0)
                                          (λ (:R1)
                                             (if (argn 0)
                                                 (return (lookup 2 0))
                                                 (return y)))))))
                     "nested lambda forms increase lookup depth")
		    ((DEFUN F (A)
		       (LAMBDA (R)
			       (+ 2 A R RETURN)
			       (Λ (CC) (> A 0 (Λ (TEST) (IF TEST (CC A) (- A CC)))))))
		     (DEFUN F (A)
		       (LAMBDA (?CC R)
			       (+ 2 (closure-lookup 0 0) (argn 1) RETURN)
			       (Λ (CC) (> (lookup 1 0) 0
					  (Λ (TEST) (IF (argn 0)
							((lookup 1 0) (lookup 2 0))
							(- (lookup 2 0) (lookup 1 0))))))))
		     "lookups for function args inside an IF lambda"))
                  :fn #'nolisp:lookup-resolver))
