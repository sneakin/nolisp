(defun setup-macroexpand ()
  (nolisp:add-macro 'boo #'(lambda (x y) `(+ ,x ,y)))
  (nolisp:add-macro 'who #'(lambda (x y) `(boo ,x ,y)))
  (nolisp:add-macro 'woo #'(lambda (x) `(who ,x ,x))))

(defun teardown-macroexpand ()
  (nolisp:remove-macro 'boo)
  (nolisp:remove-macro 'who)
  (nolisp:remove-macro 'woo)
  nil)

(defun test-macro? ()
  (setup-macroexpand)
  (assert-equal (nolisp:macro? 'boo) t)
  (assert-equal (nolisp:macro? 'who) t)
  (assert-equal (nolisp:macro? 'woo) t)
  (let ((macros (nolisp:add-macro 'coo #'(lambda (x y) `(* ,x ,y)) nolisp:*macros*)))
    (assert-equal (nolisp:macro? 'coo macros) t)
    (assert-equal (nolisp:macro? 'coo) nil))
  (teardown-macroexpand))

(defun test-macro-expand-1 ()
  (setup-macroexpand)
  (assert-equal (nolisp:macro-expand-1 '(who (boo 3 4) (who (boo 4 5) 7)))
                '(boo (boo 3 4) (who (boo 4 5) 7)))
  (assert-equal (nolisp:macro-expand-1 '(boo (boo 3 4) (who (boo 4 5) 7)))
                '(+ (boo 3 4) (who (boo 4 5) 7)))
  (assert-equal (nolisp:macro-expand-1 '(+ (boo 3 4) (who (boo 4 5) 7)))
                '(+ (+ 3 4) (boo (boo 4 5) 7)))
  (assert-equal (nolisp:macro-expand-1 '(+ (+ 3 4) (boo (boo 4 5) 7)))
                '(+ (+ 3 4) (+ (boo 4 5) 7)))
  (assert-equal (nolisp:macro-expand-1 '(+ (+ 3 4) (+ (boo 4 5) 7)))
                '(+ (+ 3 4) (+ (+ 4 5) 7)))
  (assert-equal (nolisp:macro-expand-1 '(woo (woo 3))) '(who (woo 3) (woo 3)))
  (assert-equal (nolisp:macro-expand-1 '(who (woo 3) (woo 3))) '(boo (woo 3) (woo 3)))
  (assert-equal (nolisp:macro-expand-1 '(boo (woo 3) (woo 3))) '(+ (woo 3) (woo 3)))
  (assert-equal (nolisp:macro-expand-1 '(+ (woo 3) (woo 3))) '(+ (who 3 3) (who 3 3)))
  (assert-equal (nolisp:macro-expand-1 '(+ (who 3 3) (who 3 3))) '(+ (boo 3 3) (boo 3 3)))
  (assert-equal (nolisp:macro-expand-1 '(+ (boo 3 3) (boo 3 3))) '(+ (+ 3 3) (+ 3 3)))
  (teardown-macroexpand))

(defun test-macro-expand-global ()
  (setup-macroexpand)
  (assert-equal (nolisp:macro-expand '(who (boo 3 4) (who (boo 4 5) 7)))
                '(+ (+ 3 4) (+ (+ 4 5) 7)))
  (assert-equal (nolisp:macro-expand '(woo 3)) '(+ 3 3))
  (assert-equal (nolisp:macro-expand '(woo (woo 3))) '(+ (+ 3 3) (+ 3 3)))
  (teardown-macroexpand))

(defun test-macro-expand-nonglobal ()
  (let ((macros nolisp:*macros*))
    (setf macros (nolisp:add-macro 'boom #'(lambda (x) `(* 2 ,x)) macros))
    (assert-not-equal macros *macros*)
    (assert-equal (nolisp:macro? 'boom macros) t)
    (setf macros (nolisp:add-macro 'bam #'(lambda (x) `(+ 3 ,x)) macros))
    (assert-not-equal macros *macros*)
    (assert-equal (nolisp:macro? 'bam macros) t)
    (assert-equal (nolisp:macro-expand '(boom (bam y)) macros) '(* 2 (+ 3 y)))
    (setf macros (nolisp:remove-macro 'boom macros))
    (assert-equal (nolisp:macro? 'boom macros) nil)
    (assert-equal (nolisp:macro? 'bam macros) t)))

(defun test-macro-expand-let ()
  (assert-equal (nolisp:macro-expand '(let ((x (+ 2 3))
					    (y (* 4 2)))
					(+ x y)))
		'((lambda (x y) (+ x y)) (+ 2 3) (* 4 2)))
  ;; needs to handle earlier references
  ;; (assert-equal (nolisp:macro-expand '(let ((x (+ 2 3))
  ;; 					    (y (* x 2)))
  ;; 					(+ x y)))
  ;; 		'(funcall (lambda (x y) (+ x y)) (+ 2 3) (* x 2)))
  )

(defun test-macro-expand-cond ()
  (assert-equal (nolisp:macro-expand '(cond (t 3)))
		3 "single default case")
  (assert-equal (nolisp:macro-expand '(cond ((eq x 3) 3)))
		'(if (eq x 3) 3 nil)
		"single case")
  (assert-equal (nolisp:macro-expand '(cond ((eq a 1) 10)
					    (t 3)))
		'(if (eq a 1) 10 3)
		"one case & a default case")
  (assert-equal (nolisp:macro-expand '(cond ((eq a 1) 10)
					    ((eq a 2) 20)
					    (t 30)))
		'(if (eq a 1) 10 (if (eq a 2) 20 30))
		"two cases w/ default")
  (assert-equal (nolisp:macro-expand '(cond ((eq a 1) 10)
					    ((eq a 2) 20)))
		'(if (eq a 1) 10 (if (eq a 2) 20 nil))
		"two cases w/ no default")
  (assert-equal (nolisp:macro-expand '(cond ((eq a 1) (boom 10) 10)
					    ((eq a 2) (boom 20))
					    (t 3)))
		'(if (eq a 1)
		     (progn (boom 10) 10)
		   (if (eq a 2)
		       (boom 20)
		     3))
		"two cases w/ default w/ one case w/ multiple calls")
  (assert-equal (nolisp:macro-expand '(cond ((eq a 1) (boom 10) 10)
					    ((eq a 2) (boom 20) 20)
					    (t (boom 30) 30)))
		'(if (eq a 1)
		     (progn (boom 10) 10)
		   (if (eq a 2)
		       (progn (boom 20) 20)
		     (progn (boom 30) 30)))
		"two cases and a default w/ multiple calls each")
  (assert-equal (nolisp:macro-expand '(cond (t 3)
					    ((eq a 1) (boom 10) 10)
					    ((eq a 2) (boom 20))))
		3 "default case first"))

(defun test-macro-expand ()
  (test-macro?)
  (test-macro-expand-1)
  (test-macro-expand-global)
  (test-macro-expand-nonglobal)
  (test-macro-expand-let)
  (test-macro-expand-cond)
  t)
