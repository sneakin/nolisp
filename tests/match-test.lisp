(defun test-match ()
  (assert-cases `(((?x 1) ((?x . 1)) "single var")
		  ((:x 1) ((:x . 1)) "keyword var")
		  ((?x (abc 1)) ((?x . (abc 1))) "matched sublist")
		  (((?x) (1)) ((?x . 1)) "single sublisted var")
		  (((?x) (1 2)) nil "mismatch on length")
		  (((?x 2) (1 2)) ((?x . 1)) "match first")
		  (((1 ?x) (1 2)) ((?x . 2)) "match second")
		  (((2 ?x) (1 2)) nil "mismatch first atom")
		  (((?x ?x) (2 2)) ((?x . 2)) "repeated var")
		  (((?x ?x) (1 2)) nil "unequal var value mismatch")
		  (((a ?x 1) (a xyz 1)) ((?x . xyz)) "triple")
		  (((a ?x 1) (b xyz 1)) nil "triple mismatch")
		  (((a (foo ?x) 1) (a (foo (a b)) 1)) ((?x . (a b))) "sublist match list")
		  ((((?key ?value) . ?more) ((a b) (c d) (e f)))
		   ((?more (c d) (e f)) (?value . b) (?key . a))
		   "alist matching")
		  (((a :x 1) (a xyz 1)) ((:x . xyz)) "keyword second var")
		  (((a ?x :y 2) (a b 1 2))
		   ((:y . 1) (?x . b))
		   "mix of var types")
		  ;; now with different keyword predicates
		  (((a ?x :y 2) (a ?x 1 2) :varp ,#'keywordp)
		   ((:y . 1))
		   "only keyword vars")
		  (((a ?x :y d) (a b :y d) :varp ,#'nolisp::question-sym?)
		   ((?x . b))
		   "only question mark symbols")
		  (((a ?x :y 2) (a ?x :y 3) :varp ,#'numberp)
		   ((2 . 3))
		   "numbers as vars")
		  (((a ?x :y 2) (a b :y 2) :allow-keywords nil)
		   ((?x . b))
		   "allow-keywords is nil")
		  ) #'nolisp:match))
;;; todo really test the failed test assertions

(defun test-assert-match ()
  (assert-match '(a a c c) '(?a ?a :b :b))
  (assert-match '(a a :b :b) '(?a ?a :b :b) :msg "without keywords" :allow-keywords nil)
  (assert-match '(?a ?a :b :b) '(?a ?a :b :b) :msg "with predicate" :varp #'nolisp::question-sym?)
  (assert-match '(?a ?a :b :b) '(?a ?a :b :b) :msg "with keywordp predicate" :varp #'keywordp)
)

(defun test-assert-matches ()
  (assert-matches '(((a 1 2 3) (a ?x :y 3))
		    ((a x x) (a ?b ?b)))
		  :fn #'identity)
  (assert-matches '(((1 1 :y 3) (?x ?x :y 3)))
		  :fn #'identity :allow-keywords nil)
  (assert-matches '(((a 1 :y 3) (w x y z))
		    ((a :y :y 3) (w x x z)))
		  :fn #'identity :varp #'atom))

(defun test-assert-mismatch ()
  (assert-mismatch '(a b c d) '(?a ?a c d))
  (assert-mismatch '(?a ?a c d) '(?a ?a :c :c) :msg "without keywords" :allow-keywords nil)
  (assert-mismatch '(a b c d) '(?a ?a c d) :msg "with a predicate" :varp #'nolisp::question-sym?)
  (assert-mismatch '(a b) '(?a ?a c)))

(defun test-assert-mismatches ()
  (assert-mismatches '(((b 1 2 3) (a ?x :y 3))
		       ((a x y) (a ?b ?b)))
		     :fn #'identity)
  (assert-mismatches '(((1 2 :y 3) (?x ?x :y 3)))
		     :fn #'identity :allow-keywords nil)
  (assert-mismatches '(((a 1 :y 3) (w x y z))
		       ((a :y :y 3) (w x x z)))
		     :fn #'identity :varp #'keywordp))

(defun test-match-bind ()
  (assert-equal (nolisp:match-bind ((?name . ?value) . ?rest) 'nope
				   'yes 'nope)
		'nope)
  (assert-equal (nolisp:match-bind ((?name . ?value) . ?rest)
				   '((hey . 123) (more . 456))
				   'yes 'nope)
		'yes)
  (nolisp:match-bind
   ((?name . ?value) . ?rest) '((hey . 123) (more . 456))
   (progn
     (assert-equal name 'hey)
     (assert-equal value 123)
     (assert-equal rest '((more . 456)))))
  (assert-equal
   (nolisp:match-bind ((?name . ?value) . ?rest) '(a b)
    (progn
      (assert-equal name 'hey)
      (assert-equal value 123)
      (assert-equal rest '((more . 456)))))
   nil)
  (nolisp:match-bind
   ((?name . ?value) . ?rest) '((hey . 123) (more . 456))
   (progn
     (assert-equal name 'hey)
     (assert-equal value 123)
     (assert-equal rest '((more . 456))))
   (progn 'nope))
  (assert-equal
   (nolisp:match-bind
    ((?name . ?value) . ?rest) '((hey . 123) (more . 456))
    (progn (assert-equal (list name value rest) '(hey 123 ((more . 456))))
	   :ok)
    'nope)
   :ok))

(defun test-when-match-bind ()
  (nolisp:when-match-bind yes ((?name . ?value) . ?rest) '((hey . 123) (more . 456))
			  (assert-equal yes t)
			  (assert-equal name 'hey)
			  (assert-equal value 123)
			  (assert-equal rest '((more . 456))))
  (nolisp:when-match-bind yes ((?name . ?value) . ?rest) 'nope
			  (assert-equal yes nil)
			  (assert-equal name nil)
			  (assert-equal value nil)
			  (assert-equal rest nil)))

(defun test-match-bind! ()
  (assert-equal
   (nolisp:match-bind! ((?name . ?value) . ?rest) '((hey . 123) (more . 456))
		       (assert-equal name 'hey)
		       (assert-equal value 123)
		       (assert-equal rest '((more . 456)))
		       :ok)
   :ok)
  (assert-throws
   (nolisp:match-bind! ((?name . ?value) . ?rest) 'nope
		       (assert-equal name nil)
		       (assert-equal value nil)
		       (assert-equal rest nil))
   'nolisp:match-error))

(defun test-match-case-fn (input)
  (nolisp:match-case input
		     ((a b c) :abc)
		     ((num :x) (values :num x))
		     ((?x ?y) (values :pair x y))
		     (((?key . ?value) . ?rest) (values :kv key value rest))
		     (t :default)))

(defun test-match-case ()
  (assert-equal (test-match-case-fn 'abc) :default)
  (assert-values-equal (test-match-case-fn '(1 2)) '(:pair 1 2))
  (assert-values-equal (test-match-case-fn '(num 100)) '(:num 100))
  (assert-values-equal (test-match-case-fn '((name . "Test Case") (name . "More")))
		       '(:pair (name . "Test Case") (name . "More")))
  (assert-values-equal (test-match-case-fn '((name . "Test Case")
					     (name . "More")
					     (name . "And More")))
		       '(:kv name "Test Case" ((name . "More") (name . "And More")))))

(defun test-matching ()
  (test-match)
  (test-assert-match)
  (test-assert-matches)
  (test-assert-mismatch)
  (test-assert-mismatches)
  (test-when-match-bind)
  (test-match-bind)
  (test-match-bind!)
  (test-match-case)
  t)
