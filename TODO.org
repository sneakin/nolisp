#+TITLE: NoLisp3 Plan
#+AUTHOR: Nolan Eakins <sneakin-at-semanticgap.com>

* Todo
** Compiler top level
   Compile multiple expressions into a single Forth output.
*** DONE defun
*** macros
**** DONE evaluable in definitions
**** DONE top level evaluable
**** Unable to call macros from the macros.
*** DONE defvar
    Initialized at runtime
*** DONE defconstant
*** DONE evaluable forms

** Quoting
*** DONE quote
   Needs forthgen output
   Lookup Resolver ignoring
*** backquote
    ~`(word ,include ,@append)~
**** Needs to eval forms that are unquoted

** Data types
*** Lists
*** Integers
*** Symbols and keywords
*** Sequences and Strings
*** Floats
*** Structures
*** Dynamic typing

** Tighter closures where closed bindings get passed to close-lombda?

** Recursion
   North uses ~repeat-frame~ to recurse. Functions need to substitute calls
   to self with that.
*** defun
    Lookup to replace self calls.
*** named lambdas
    Optional name before the arglist.
    #+BEGIN_SRC lisp
      (lambda name arglist body...)
    #+END_SRC

** Doc strings
   #+BEGIN_SRC lisp
     (defun fn (x)
       "Documentation here"
       body...)
   #+END_SRC
*** Skip and ignore
*** Symbol table inclusion or assoc list for ~documentation~.

** Macros
*** (execute (eval-when)) macro

** Arglists
   ~&optional~, ~&key~, and ~&rest~ arguments
   #+BEGIN_SRC lisp
     (defun fn (x y &optional (z 0) (w 1) &key (normalized t) &rest body)
       body)

     (fn 1 2)
     (fn 1 2 3)
     (fn 1 2 3 4 :normalized nil)
     (fn 1 2 3 4 :normalized nil 100 200)
     (fn 1 2 :normalized t) ;; error
   #+END_SRC

   #+BEGIN_SRC
     \( defun symbol
              \( reqd*
	         (&optional (name | \( name default \))*)?
                 (&key (name | \( name default \))*)?
                 (&rest name)?
              \)
	 expr* \)
   #+END_SRC
   
   Functions calls need to:
     - populate missing optional and keyword arguments and terminate &rest arguments.
     - resolve to a numbered version of the function
     - and/or count the arguments and call a generalized wrapper that populates
        missing arguments. Kind of gets into how all calls are made: reuse list
	made when reading?

   Arguments on stack:
     - Optional arguments :: filled in at call or filled by wrapper
     - Keywords :: sorted and filled in like optional arguments
     - Rest :: just a stack pointer, terminated to become a proper list / sequence
*** defun
*** lambdas
*** calls

** Runtime
*** North and/or Forth?
*** Functions used by generated code
*** (apply)
*** (funcall)
*** Functions for self compilation
*** eval

** Garbage collection
   A basic copy list that keeps what can be reached from the current frame.

** Inner frame elimination?
   Use ~overn~ to directly access stack data. Functions with variable length,
   allocated returns would complicate.

** Multiple value returns
*** (values x+)
    Return values
*** (values-list list)
    Returns list as multiple values.
*** (multiple-value-list expr)
    Returns values returned by ~expr~ as a list.
*** (multiple-value-bind (bindings+) expr exprs*)
    Binds the values returned by ~expr~ to the ~bindings~ for use by the ~exprs~.
*** apply and/or funcall values

** callcc
   #+BEGIN_SRC lisp
     (print (callcc (cc) (print 'new-thread) (setf x cc) (funcall cc :done)))
     (print 'after)
   #+END_SRC

** Methods
   Functions that dispatch on argument types.
   #+BEGIN_SRC lisp
     (defmethod to-float ((float n)) n)
     (defmethod to-float ((integer n)) (int->float n))
     (defmethod to-float ((string n)) (parse-float n))
     (defmethod sqrt ((float n)) (float-sqrt n))
     (defmethod sqrt (n) (sqrt (to-float n)))
   #+END_SRC

** Reader
   Read a byte buffer / stream into symbols and lists.
   Macros triggered by characters needed for quote, function quote, and backquote.

** Assembler
*** Inline assembly
*** Standalone tool
*** Assembly output of a call thread

** Specially made stack machine interpreter
*** Flattened indirect lists
*** Lists

** REPL top level
   Definitions modify the running system, with saving of the running image.

